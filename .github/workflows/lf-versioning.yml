name: "Versioning"

on:
  push:
    branches:
      - main

jobs:
  versioning:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version_update.outputs.new_version }}

    steps:
      - name: "Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for full commit history

      - name: "Check if Latest Commit is Tagged"
        id: check_commit_tag
        run: |
          TAG=$(git tag --points-at HEAD)
          if [[ -n "$TAG" ]]; then
            echo "latest_commit_tag=$TAG" >> $GITHUB_ENV
            echo "tagged=true" >> $GITHUB_ENV
          else
            echo "latest_commit_tag=" >> $GITHUB_ENV
            echo "tagged=false" >> $GITHUB_ENV
          fi

      - name: "Try to Download Latest Version Artifact"
        id: download_previous_version
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: version
          path: .

      - name: "Extract Previous Version from Artifact"
        id: extract_version
        run: |
          if [[ -s "version/version.txt" ]]; then
            PREVIOUS_VERSION=$(cat version/version.txt)
            echo "Previous version found: $PREVIOUS_VERSION"
          else
            PREVIOUS_VERSION="1.0.0.0"
            echo "No previous version found, defaulting to $PREVIOUS_VERSION"
          fi
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_ENV

      - name: "Create Version Bump Script"
        run: |
          cat <<EOF > bump_version.py
          import os
          import subprocess
          import re

          # Get previous version
          previous_version = os.getenv("previous_version", "1.0.0.0").strip()

          # Parse version into components
          parts = previous_version.split(".")
          while len(parts) < 4:
              parts.append("0")  # Ensure at least major.minor.patch.revision
          
          major, minor, patch, revision = map(int, parts)

          # Get commit messages since last version tag
          commit_messages = subprocess.run(
              ["git", "log", "--pretty=%s", "--no-merges"],
              capture_output=True,
              text=True
          ).stdout.splitlines()

          # Determine version bump type
          bump_type = "revision"
          for msg in commit_messages:
              if "BREAKING CHANGE" in msg or re.search(r"(feat|fix)!:", msg):
                  bump_type = "major"
                  break
              elif msg.startswith("feat:"):
                  bump_type = "minor"
              elif msg.startswith("fix:") and bump_type != "minor":
                  bump_type = "patch"

          # Apply version bump
          if bump_type == "major":
              major += 1
              minor, patch, revision = 0, 0, 0
          elif bump_type == "minor":
              minor += 1
              patch, revision = 0, 0
          elif bump_type == "patch":
              patch += 1
              revision = 0
          else:  # revision bump
              revision += 1

          new_version = f"{major}.{minor}.{patch}.{revision}"

          print(f"previous version: {version}")
          print(f"new version: {new_version}")

          # Output new version
          with open("version.txt", "w") as f:
              f.write(new_version)

          print(new_version)
          EOF

      - name: "Run Version Bump Script"
        id: version_update
        run: |
          NEW_VERSION=$(python3 bump_version.py)
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV
          echo "$NEW_VERSION" > version.txt
          echo "New version: $NEW_VERSION"

      - name: "Upload New Version as Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: version
          path: version.txt
